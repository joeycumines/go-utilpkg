//go:build ignore

// This file is no longer needed - fixes have been applied to the original files.
package gojaeventloop

import (
	"context"
	"sync"
	"testing"
	"time"

	"github.com/dop251/goja"
	goeventloop "github.com/joeycumines/go-eventloop"
)

// ===============================================
// EXPAND-020: process.nextTick() JS Binding Tests
// ===============================================

func TestProcessNextTick_Basic(t *testing.T) {
	loop, err := goeventloop.New()
	if err != nil {
		t.Fatalf("New failed: %v", err)
	}
	defer loop.Shutdown(context.Background())

	runtime := goja.New()
	adapter, err := New(loop, runtime)
	if err != nil {
		t.Fatalf("New adapter failed: %v", err)
	}

	if err := adapter.Bind(); err != nil {
		t.Fatalf("Bind failed: %v", err)
	}

	done := make(chan struct{})
	var result string
	var mu sync.Mutex

















































































































































































































































































































































































































































}	}		t.Error("delay(-100) did not resolve in time")	case <-time.After(time.Second):		// Success - negative delay should be treated as 0	case <-done:	select {	}()		_ = loop.Run(context.Background())	go func() {	}		t.Fatalf("RunString failed: %v", err)	if err != nil {	`)		delay(-100).then(onDone);	_, err = runtime.RunString(`	})		return goja.Undefined()		close(done)	runtime.Set("onDone", func(call goja.FunctionCall) goja.Value {	done := make(chan struct{})	}		t.Fatalf("Bind failed: %v", err)	if err := adapter.Bind(); err != nil {	}		t.Fatalf("New adapter failed: %v", err)	if err != nil {	adapter, err := New(loop, runtime)	runtime := goja.New()	defer loop.Shutdown(context.Background())	}		t.Fatalf("New failed: %v", err)	if err != nil {	loop, err := goeventloop.New()func TestDelay_NegativeValueTreatedAsZero(t *testing.T) {}	}		t.Error("delay() should return a promise-like object with then and catch methods")	if !result.ToBoolean() {	}		t.Fatalf("RunString failed: %v", err)	if err != nil {	`)		typeof p.then === 'function' && typeof p.catch === 'function';		var p = delay(0);	result, err := runtime.RunString(`	}		t.Fatalf("Bind failed: %v", err)	if err := adapter.Bind(); err != nil {	}		t.Fatalf("New adapter failed: %v", err)	if err != nil {	adapter, err := New(loop, runtime)	runtime := goja.New()	defer loop.Shutdown(context.Background())	}		t.Fatalf("New failed: %v", err)	if err != nil {	loop, err := goeventloop.New()func TestDelay_ReturnsPromise(t *testing.T) {}	}		t.Error("Chain did not complete in time")	case <-time.After(time.Second):		}			t.Errorf("Unexpected order: %v", order)		if order[0] != "first" || order[1] != "second" {		}			t.Fatalf("Expected 2 calls, got %d", len(order))		if len(order) != 2 {		defer mu.Unlock()		mu.Lock()	case <-done:	select {	}()		_ = loop.Run(context.Background())	go func() {	}		t.Fatalf("RunString failed: %v", err)	if err != nil {	`)			});				recordOrder("second");			.then(function(v) {			})				return "value";				recordOrder("first");			.then(function() {		delay(10)	_, err = runtime.RunString(`	})		return goja.Undefined()		mu.Unlock()		}			close(done)		if len(order) == 2 {		order = append(order, call.Argument(0).String())		mu.Lock()	runtime.Set("recordOrder", func(call goja.FunctionCall) goja.Value {	var mu sync.Mutex	var order []string	done := make(chan struct{})	}		t.Fatalf("Bind failed: %v", err)	if err := adapter.Bind(); err != nil {	}		t.Fatalf("New adapter failed: %v", err)	if err != nil {	adapter, err := New(loop, runtime)	runtime := goja.New()	defer loop.Shutdown(context.Background())	}		t.Fatalf("New failed: %v", err)	if err != nil {	loop, err := goeventloop.New()func TestDelay_Chaining(t *testing.T) {}	}		t.Error("delay(0) did not resolve in time")	case <-time.After(time.Second):		// Success	case <-done:	select {	}()		_ = loop.Run(context.Background())	go func() {	}		t.Fatalf("RunString failed: %v", err)	if err != nil {	`)		delay(0).then(onDone);	_, err = runtime.RunString(`	})		return goja.Undefined()		close(done)	runtime.Set("onDone", func(call goja.FunctionCall) goja.Value {	done := make(chan struct{})	}		t.Fatalf("Bind failed: %v", err)	if err := adapter.Bind(); err != nil {	}		t.Fatalf("New adapter failed: %v", err)	if err != nil {	adapter, err := New(loop, runtime)	runtime := goja.New()	defer loop.Shutdown(context.Background())	}		t.Fatalf("New failed: %v", err)	if err != nil {	loop, err := goeventloop.New()func TestDelay_ZeroMs(t *testing.T) {}	}		t.Error("delay() did not resolve in time")	case <-time.After(time.Second):		}			t.Errorf("delay() resolved too quickly: %v", elapsed)		if elapsed < 40*time.Millisecond {		}			t.Error("delay() did not resolve")		if !resolved {		defer mu.Unlock()		mu.Lock()		elapsed := time.Since(start)	case <-done:	select {	start := time.Now()	}()		_ = loop.Run(context.Background())	go func() {	}		t.Fatalf("RunString failed: %v", err)	if err != nil {	`)		});			onResolved();		delay(50).then(function() {	_, err = runtime.RunString(`	})		return goja.Undefined()		close(done)		mu.Unlock()		resolved = true		mu.Lock()	runtime.Set("onResolved", func(call goja.FunctionCall) goja.Value {	var mu sync.Mutex	var resolved bool	done := make(chan struct{})	}		t.Fatalf("Bind failed: %v", err)	if err := adapter.Bind(); err != nil {	}		t.Fatalf("New adapter failed: %v", err)	if err != nil {	adapter, err := New(loop, runtime)	runtime := goja.New()	defer loop.Shutdown(context.Background())	}		t.Fatalf("New failed: %v", err)	if err != nil {	loop, err := goeventloop.New()func TestDelay_Basic(t *testing.T) {// ===============================================// EXPAND-021: delay() JS Binding Tests// ===============================================}	}		t.Fatalf("RunString failed: %v", err)	if err != nil {	// Should not cause a Go panic	`)		}			// Expected TypeError		} catch (e) {			process.nextTick();		try {	_, err = runtime.RunString(`	}		t.Fatalf("Bind failed: %v", err)	if err := adapter.Bind(); err != nil {	}		t.Fatalf("New adapter failed: %v", err)	if err != nil {	adapter, err := New(loop, runtime)	runtime := goja.New()	defer loop.Shutdown(context.Background())	}		t.Fatalf("New failed: %v", err)	if err != nil {	loop, err := goeventloop.New()func TestProcessNextTick_NoArgumentError(t *testing.T) {}	}		t.Error("Callbacks did not execute in time")	case <-time.After(time.Second):		}			}				t.Errorf("At index %d: expected %d, got %d", i, v, order[i])			if order[i] != v {		for i, v := range expected {		expected := []int{1, 2, 3}		defer mu.Unlock()		mu.Lock()	case <-done:	select {	}()		_ = loop.Run(context.Background())	go func() {	}		t.Fatalf("RunString failed: %v", err)	if err != nil {	`)		process.nextTick(function() { recordOrder(3); });		process.nextTick(function() { recordOrder(2); });		process.nextTick(function() { recordOrder(1); });	_, err = runtime.RunString(`	})		return goja.Undefined()		mu.Unlock()		}			close(done)		if len(order) == 3 {		order = append(order, int(call.Argument(0).ToInteger()))		mu.Lock()	runtime.Set("recordOrder", func(call goja.FunctionCall) goja.Value {	var mu sync.Mutex	var order []int	done := make(chan struct{})	}		t.Fatalf("Bind failed: %v", err)	if err := adapter.Bind(); err != nil {	}		t.Fatalf("New adapter failed: %v", err)	if err != nil {	adapter, err := New(loop, runtime)	runtime := goja.New()	defer loop.Shutdown(context.Background())	}		t.Fatalf("New failed: %v", err)	if err != nil {	loop, err := goeventloop.New()func TestProcessNextTick_Multiple(t *testing.T) {}	}		t.Error("Callbacks did not execute in time")	case <-time.After(time.Second):		}			t.Errorf("Expected 'promise' second, got order: %v", order)		if order[1] != "promise" {		}			t.Errorf("Expected 'nextTick' first, got order: %v", order)		if order[0] != "nextTick" {		}			t.Fatalf("Expected 2 items, got %d", len(order))		if len(order) != 2 {		defer mu.Unlock()		mu.Lock()	case <-done:	select {	}()		_ = loop.Run(context.Background())	go func() {	}		t.Fatalf("RunString failed: %v", err)	if err != nil {	`)		});			recordOrder("nextTick");		process.nextTick(function() {		// nextTick should run before promise		});			recordOrder("promise");		Promise.resolve().then(function() {		// Promise.then is a microtask	_, err = runtime.RunString(`	})		return goja.Undefined()		mu.Unlock()		}			close(done)		if len(order) == 2 {		order = append(order, call.Argument(0).String())		mu.Lock()	runtime.Set("recordOrder", func(call goja.FunctionCall) goja.Value {	var mu sync.Mutex	var order []string	done := make(chan struct{})	}		t.Fatalf("Bind failed: %v", err)	if err := adapter.Bind(); err != nil {	}		t.Fatalf("New adapter failed: %v", err)	if err != nil {	adapter, err := New(loop, runtime)	runtime := goja.New()	defer loop.Shutdown(context.Background())	}		t.Fatalf("New failed: %v", err)	if err != nil {	loop, err := goeventloop.New()func TestProcessNextTick_RunsBeforePromise(t *testing.T) {}	}		t.Error("Callback did not execute in time")	case <-time.After(time.Second):		}			t.Errorf("Expected 'called', got: %s", result)		if result != "called" {		defer mu.Unlock()		mu.Lock()	case <-done:	select {	}()		_ = loop.Run(context.Background())	go func() {	}		t.Fatalf("RunString failed: %v", err)	if err != nil {	`)		});			setResult("called");		process.nextTick(function() {	_, err = runtime.RunString(`	})		return goja.Undefined()		close(done)		mu.Unlock()		result = call.Argument(0).String()		mu.Lock()	runtime.Set("setResult", func(call goja.FunctionCall) goja.Value {